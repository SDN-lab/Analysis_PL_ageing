---
title: "Prosocial_learning_analysis"
author: "Jo Cutler & Patricia Lockwood"
date: "28/01/2020"
output: html_document
---

## Set up and functions

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
options(digits = 2)

# load required packages and functions

require(pacman)
pacman::p_load(tidyverse, readxl, sjstats, effects, lme4, lmerTest, MASS, car, gridExtra, DataExplorer, broom, pander, scales, robustlmm, emmeans, Hmisc, psych, kableExtra, plyr, ggpubr, fitdistrplus, tidyr, stringi, robust, ggsignif, ppcor, ggtext, rstatix, coin, ggpubr)

### Function to produce reporting stats for rlmer objects

## Wald confidence interval code adapted from Ben Bolker at 
## https://gist.github.com/kamermanpr/aaa598485b6e990017375359ff5f4533)

## Then z-value and p-value generation added by Anthony Gabay 12/08/19

stats.rlmerMod <- function(object, level = 0.95) {
  
  # Extract beta coefficients
  beta <- fixef(object)
  
  # Extract names of coefficients
  parm <- names(beta)
  
  # Extract standard errors for the coefficients
  se <- sqrt(diag(vcov(object)))
  
  # Set level of confidence interval
  conf.level <- qnorm((1 + level) / 2)
  
  # Calculate z value
  z = beta/se
  
  # Calculate CI and create table
  ctab <- cbind(beta,
                beta - (conf.level * se), 
                beta + (conf.level * se),
                se,
                z,
                2*pnorm(-abs(z)))
  
  
  # label column names
  colnames(ctab) <- c('beta',
                      paste(100 * ((1 - level) / 2), '%'),
                      paste(100 * ((1 + level) / 2), '%'),
                      'SE',
                      'z',
                      'p')
  
  # Output
  return(ctab)
  
}

stats.rlmMod <- function(object, level = 0.95) {
  # Extract beta coefficients
  beta <- object$coefficients
  
  # Extract names of coefficients
  parm <- names(beta)
  
  # Extract standard errors for the coefficients
  se <- sqrt(diag(vcov(object)))
  
  # Set level of confidence interval
  conf.level <- qnorm((1 + level) / 2)
  
  # Calculate z value
  z = beta/se
  
  # Calculate v value
  p <- 2*pnorm(-abs(z))
  
  # Calculate CI and create table
  ctab <- cbind(beta,
                beta - (conf.level * se), 
                beta + (conf.level * se),
                se,
                z,
                p)
  
  
  # label column names
  colnames(ctab) <- c('beta',
                      paste(100 * ((1 - level) / 2), '%'),
                      paste(100 * ((1 + level) / 2), '%'),
                      'SE',
                      'z',
                      'p')
  
  # Output
  return(ctab)
  
}

### Function to format p values taken from https://stackoverflow.com/questions/23018256/printing-p-values-with-0-001

pvalr <- function(pvals, sig.limit = .001, digits = 3, html = FALSE) {
  
  roundr <- function(x, digits = 1) {
    res <- sprintf(paste0('%.', digits, 'f'), x)
    zzz <- paste0('0.', paste(rep('0', digits), collapse = ''))
    res[res == paste0('-', zzz)] <- zzz
    res
  }
  
  sapply(pvals, function(x, sig.limit) {
    if (x < sig.limit)
      if (html)
        return(sprintf('&lt; %s', format(sig.limit))) else
          return(sprintf('<%s', format(sig.limit)))
    if (x > .1)
      return(roundr(x, digits = 2)) else
        return(roundr(x, digits = digits))
  }, sig.limit = sig.limit)
}

### Functions to format tables adapted from stats.rlmerMod above by Jo Cutler 25/02/20

stats.rlmerMod.f <- function(object, level = 0.95) {
  
  # Extract beta coefficients
  beta <- fixef(object)
  
  # Extract names of coefficients
  parm <- names(beta)
  
  # Extract standard errors for the coefficients
  se <- sqrt(diag(vcov(object)))
  
  # Set level of confidence interval
  conf.level <- qnorm((1 + level) / 2)
  
  # Calculate z value
  z = beta/se
  
  # Calculate v value
  p <- 2*pnorm(-abs(z))
  
  # Calculate CI and create table
  ctab <- cbind(sprintf("%.3f", signif(beta,2)),
                sprintf("%.3f", signif(beta - (conf.level * se))), 
                sprintf("%.3f", signif(beta + (conf.level * se))),
                sprintf("%.3f", signif(se,2)),
                round(z,2),
                pvalr(p))
  
  
  # label column names
  colnames(ctab) <- c('beta',
                      paste(100 * ((1 - level) / 2), '%'),
                      paste(100 * ((1 + level) / 2), '%'),
                      'SE',
                      'z',
                      'p')
  
  # Output
  return(ctab)
  
}

### Functions to format tables from rlm (instead of rlmer) objects adapted from stats.rlmerMod.f above by Jo Cutler 25/02/20

stats.rlmMod.f <- function(object, level = 0.95) {
  # Extract beta coefficients
  beta <- object$coefficients
  
  # Extract names of coefficients
  parm <- names(beta)
  
  # Extract standard errors for the coefficients
  se <- sqrt(diag(vcov(object)))
  
  # Set level of confidence interval
  conf.level <- qnorm((1 + level) / 2)
  
  # Calculate z value
  z = beta/se
  
  # Calculate v value
  p <- 2*pnorm(-abs(z))
  
  # Calculate CI and create table
  ctab <- cbind(sprintf("%.3f", signif(beta,2)),
                sprintf("%.3f", signif(beta - (conf.level * se))), 
                sprintf("%.3f", signif(beta + (conf.level * se))),
                sprintf("%.3f", signif(se,2)),
                round(z,2),
                pvalr(p))
  
  
  # label column names
  colnames(ctab) <- c('beta',
                      paste(100 * ((1 - level) / 2), '%'),
                      paste(100 * ((1 + level) / 2), '%'),
                      'SE',
                      'z',
                      'p')
  
  # Output
  return(ctab)
  
}

```

## General settings

```{r}

# 1 to save plots, 0 to not save
saveplots <- 0

# settings used throughout script to make figures the same height and text size
resolution <- 1200
plotH <- 4
axtext <- 18
axtitle <- 20

```

## Plots of model identifiability, parameter recovery & model fit

``` {r}

modplotW <- plotH * 1.55 # set up dimensions to save figure
modprplotW <- plotH * 1.63
modfitplotW <- modplotW / 2

## Model identifiability

df.mi <- read_xlsx("Model_identifiability_em.xlsx", sheet = 1, col_names = T)

df.mi <- df.mi %>%
  mutate(Simulated = factor(Simulated,
                            levels = c(1,2,3,4),
                            labels = c(paste0("1","\u03B1","1","\u03B2"), # rename models with alpha and beta symbols
                                       paste0("3","\u03B1","1","\u03B2"),
                                       paste0("2","\u03B1","1","\u03B2"),
                                       paste0("3","\u03B1","3","\u03B2")))) %>%
  mutate(Estimated = factor(Estimated,
                            levels = c(1,2,3,4),
                            labels = c(paste0("1","\u03B1","1","\u03B2"),
                                       paste0("3","\u03B1","1","\u03B2"),
                                       paste0("2","\u03B1","1","\u03B2"),
                                       paste0("3","\u03B1","3","\u03B2"))))

if (saveplots == 1) {tiff("Plots/Model_iden_xp.tiff", units="in", res = resolution, width = modplotW, height = plotH)}

xp.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=xp)) + 
  geom_tile() +
  scale_fill_distiller(palette = "PuBu", direction = 1,
                       limit = c(0,1), space = "Lab",       
                       name="Exceedance probability") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

xp.plot

if (saveplots == 1) {dev.off()}

if (saveplots == 1) {tiff("Plots/Model_iden_best.tiff", units="in", res = resolution, width = modplotW, height = plotH)}

bm.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=best)) + 
  geom_tile() +
  scale_fill_distiller(palette = "PuBuGn", direction = 1,
                       limit = c(0,10), space = "Lab",                      
                       name="Best model (of 10)") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

bm.plot

if (saveplots == 1) {dev.off()}

## Parameter recovery

df.pr <- read_xlsx("Parameter_recovery_em.xlsx", sheet = 1, col_names = T)

pal <- c("#F6E8C3", "#F5F5F5", "#C7EAE5", "#80CDC1", "#35978F", "#01665E", "#003C30") # create colour palette

if (saveplots == 1) {tiff("Plots/Parameter_recovery.tiff", units="in", res = resolution, width = modprplotW, height = plotH)}

h.plot <- ggplot(data = df.pr, aes(x=Simulated, y=Recovered, fill=HCorr)) + 
  geom_tile() +
  scale_fill_gradientn(colours = pal,
                       limit = c(-0.25,1.05), 
                       name="Pearson's r") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE, override.aes = list(limits = c(0,1)))) +
  scale_x_continuous(breaks = c(1,2,3,4),
                     labels = c(paste0("\u03B1","<sub>self</sub>"), # rename models with alpha and beta symbols
                                paste0("\u03B1","<sub>other</sub>"),
                                paste0("\u03B1","<sub>no one</sub>"),
                                paste0("\u03B2"))) +
  scale_y_continuous(breaks = c(1,2,3,4),
                     labels = c(paste0("\u03B1","<sub>self</sub>"),
                                paste0("\u03B1","<sub>other</sub>"),
                                paste0("\u03B1","<sub>no one</sub>"),
                                paste0("\u03B2"))) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, angle = 90), 
        legend.text = element_text(size = axtext))

h.plot

if (saveplots == 1) {dev.off()}

## Model fit

df.fit <- read_xlsx("PL_model_fit_statistics.xlsx", sheet = 1, col_names = T)

df.fit <- df.fit %>%
  mutate(Model = factor(model,
                        levels = c(1,2,3,4),
                        labels = c(paste0("1","\u03B1","1","\u03B2"), # rename models with alpha and beta symbols
                                   paste0("3","\u03B1","1","\u03B2"),
                                   paste0("2","\u03B1","1","\u03B2"),
                                   paste0("3","\u03B1","3","\u03B2")))) 

if (saveplots == 1) {tiff("Plots/Model_fit_bic.tiff", units="in", res = resolution, width = modfitplotW, height = plotH)}

fit.bic.plot <- ggplot(data = df.fit, aes(x=Model, y=bicint)) +
  geom_point(aes(shape = Model), color = 'black', size = 5) + 
  labs(x= NULL,
       y = "Integrated BIC<br>
        <span style='font-size:14pt'>(*lower* is better)</span>") +
  scale_shape_manual(values = c(18,17,18,18))  +
  theme_classic() + 
  theme(legend.position = "none") + 
  theme(axis.text.x=element_markdown(size = axtext, angle = 90, vjust=0.5), 
        axis.text.y=element_text(size = axtext),
        axis.title = element_markdown(size = axtitle), 
        axis.title.y = element_markdown(size = axtitle))

fit.bic.plot

if (saveplots == 1) {dev.off()}

if (saveplots == 1) {tiff("Plots/Model_fit_xp.tiff", units="in", res = resolution, width = modfitplotW, height = plotH)}

fit.xp.plot <- ggplot(data = df.fit, aes(x=Model, y=xp)) +
  geom_point(aes(shape = Model), color = 'black', size = 5) +
  labs(x= NULL,
       y = "Exceedance probability<br>
        <span style='font-size:14pt'>(*higher* is better)</span>") +
  scale_shape_manual(values = c(18,17,18,18))  +
  theme_classic() + 
  theme(legend.position = "none") + 
  theme(axis.text.x=element_markdown(size = axtext, angle = 90, vjust=0.5), 
        axis.text.y=element_text(size = axtext),
        axis.title = element_markdown(size = axtitle), 
        axis.title.y = element_markdown(size = axtitle))

fit.xp.plot

if (saveplots == 1) {dev.off()}

```

## Compare model fit between groups

```{r}

# loads data
group.fit <- read_xlsx("Compare_fit_between_groups.xlsx", sheet = 1, col_names = T) 
group.fit <- group.fit %>%
  mutate(group = factor(group, 
                        levels = c(1,2), 
                        labels = c("young", "old"))) 

hist(group.fit$fit)
describe(group.fit$fit)

group.fit.av <- group.fit %>%
  dplyr::group_by(group) %>%
  dplyr::summarise(n = n(), mean = mean(fit,na.rm=T), median = median(fit,na.rm=T), sd = sd(fit,na.rm=T), se = sd/sqrt(n))

wil.group.fit <- wilcox.test(
  group.fit$fit[group.fit$group == "young"],
  group.fit$fit[group.fit$group == "old"],
  paired = FALSE)

Zstat.group.fit  <- qnorm(wil.group.fit$p.value/2)

fit.es <- group.fit %>% wilcox_effsize(fit ~ group, ci = TRUE)

```

## Trial-by-trial analysis and plot (checking learning):

```{r message=FALSE, warning=FALSE, results='hide', fig.keep='last'}

# [Note method to format figure outputs lots of text and multiple versions so suppress output here]

## Load and organise the data

df.tbt <- read_xlsx("Task_data_trial_by_trial.xlsx", sheet = 1, col_names = T) 

df.tbt <- df.tbt %>%
  mutate(choice = factor(choice)) %>%
  mutate(outcome = factor(outcome)) %>%
  mutate(group = factor(group, 
                        levels = c(1,2), 
                        labels = c("young", "old")))    %>% # factorise group with text labels
  mutate(ID = factor(ID, 
                     levels = c(unique(df.tbt$ID)),
                     ordered=F))               %>% # factorise ID
  mutate(agent = factor(agent, 
                        levels = c(1, 2, 3),
                        labels = c("self", "other", "noone"), ordered=F)) %>% # factorise agent with text labels
  mutate(condition = interaction(agent, group, sep = ":")) # create a variable for the interaction between agent & group

df.tbt.c <- df.tbt[complete.cases(df.tbt$choice), ] # create a version with only trials a choice was made to use in models below
df.tbt.c$trialno <- df.tbt.c$trialno /10 # rescale so scale more similar to other variables in model
df.tbt.c$trialno <- df.tbt.c$trialno - mean(df.tbt.c$trialno) # mean centre for use as a predictor

df.tav <- read_xlsx("Task_data_participant_averages.xlsx", sheet = 1, col_names = T) 

df.tav <- df.tav %>%
  mutate(group = factor(group, 
                        levels = c(1,2), 
                        labels = c("young", "old")))    %>% # factorise group with text labels
  mutate(ID = factor(ID, ordered=F))               %>% # factorise ID
  mutate(agent = factor(agent, 
                        levels = c(1, 2, 3),
                        labels = c("self", "other", "noone"), ordered=F)) %>%# factorise agent with text labels
  mutate(condition = interaction(agent, group, sep = ":"))  # create a variable for the interaction between agent & group

# Check learning - percentage correct is above 50% and effect of trial number for each age*recipient condition

df.tav.lt <- subset(df.tav, trialno > min(trialno)) # change this to look at only later parts of the task
df.tav.lt$trialno = df.tav.lt$trialno - mean(df.tav.lt$trialno) # mean centre trial number for use as predictor in model
learning.t <- list()
learning.p <- list()
learning.m <- list()
learning.rm <- list()
for (a in c("self", "other", "noone")) {
  for (g in c("young", "old")) {
    df.tav.cond <- subset(df.tav.lt, agent == a)
    df.tav.cond <- subset(df.tav.cond, group == g)
    df.tbt.cond <- subset(df.tbt, agent == a)
    df.tbt.cond <- subset(df.tbt.cond, group == g)
    name <- paste0(g,':',a)
    learning.t[[name]] <- t.test(df.tav.cond$choiceP, mu = 50)
    learning.p[[name]] <- learning.t[[name]]$p.value
    learning.m[[name]] <- glmer(choice ~ trialno + (1|ID), data = df.tbt.cond, family = binomial, contrasts = NULL)
    learning.rm[[name]] <- glmer(choice ~ trialno + (1 + trialno |ID), data = df.tbt.cond, family = binomial, contrasts = NULL)
  }
}

# Plot of choices on each trial

sidelegend <- 0 # 1 = default, 0 = overlapping plot

if (sidelegend == 1) {
  tbtplotname <- "Plots/Percentage_correct_side_legend.tiff"
  tbtplotW <- plotH * 2.4
  tbtlegpos <- "right"
} else {
  tbtplotname <- "Plots/Percentage_correct.tiff"
  tbtplotW <- plotH * 1.6
  tbtlegpos <- c(.68, .25)
}

pltorder <- c(1, 4, 2, 5, 3, 6)

tbtcolnames <- ("Self   Other  No one")

tbt3cols <- c('#365F91', '#3C859A', '#60487A', '#365F91', '#3C859A', '#60487A') # [self, other, no one] * 2 as graph applies alpha to older bars
tbt3fills <-c('#365F91', '#3C859A', '#60487A', 'white', 'white', 'white') # [self, other, no one] * 2 as same for young and older
tbt3shapes <- c(22, 21, 24, 22, 21, 24)

tbtinteractionlims <- c('self:young', 'other:young', 'noone:young', 'self:old', 'other:old', 'noone:old')
tbtinteractionlabs <- c('', '', '','', 'Young', 'Older')

tbtinteractionlims <- tbtinteractionlims[pltorder]
tbt3shapes <- tbt3shapes[pltorder]
tbt3cols <- tbt3cols[pltorder]
tbt3fills <- tbt3fills[pltorder]

plt.data <- df.tav %>%
  dplyr::group_by(agent, group, condition, trialno) %>%
  dplyr::summarise(n = n(), mean = mean(choiceP,na.rm=T), sd = sd(choiceP,na.rm=T), se = sd/sqrt(n))

if (saveplots == 1) {tiff(tbtplotname, units="in", width = tbtplotW, height = plotH, res = resolution)}

plot.tbt <- ggplot(plt.data, aes(x = trialno, y = mean, group = condition)) + 
  geom_errorbar(aes(ymin = mean-se, ymax = mean+se, color = condition), position=position_dodge(.5), width = 0) +
  geom_line(aes(group = condition, color = condition), position=position_dodge(.5), size = 0.75, show.legend = FALSE) + 
  geom_point(aes(color = condition, shape = condition, fill = condition), position=position_dodge(.5), size = 3) + 
  scale_x_continuous(name = 'Trial number', breaks = seq(1, 16, 1)) +
  scale_y_continuous(name = 'Percentage correct', breaks = seq(20, 100, 10)) + 
  coord_cartesian(ylim=c(20, 100)) + 
  scale_color_manual(name = tbtcolnames, limits = tbtinteractionlims, values = tbt3cols, labels = tbtinteractionlabs) +
  scale_fill_manual(name = tbtcolnames, limits = tbtinteractionlims, values = tbt3fills, labels = tbtinteractionlabs) +  
  scale_shape_manual(name = tbtcolnames, limits = tbtinteractionlims, values = tbt3shapes, labels = tbtinteractionlabs) +
  theme_classic() + 
  theme(legend.text = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle, hjust = 0.075, vjust = 0), 
        legend.key.width = unit(0.6,"in"),
        legend.key.height = unit(0.4,"in"),
        legend.key = element_rect(color = NA),
        axis.text=element_text(size = axtext), 
        axis.title=element_text(size = axtitle),
        legend.position = tbtlegpos
  ) +
  guides(fill=guide_legend(ncol=3),
         color=guide_legend(ncol=3), 
         shape=guide_legend(ncol=3,
                            override.aes = list(size = 1.5)), 
         keywidth = unit(10,"cm"), 
         keyheight = unit(10,"cm"))

# to change size of shapes without lines becoming as thick as shapes
plot.tbt
grid::grid.ls(grid::grid.force())
grid::grid.gedit("key-[-0-9]-[1-9]", size = unit(0.2, "in"))
plot.tbt <- grid::grid.grab()

if (saveplots == 1) {
  plot.tbt
  dev.off()}

```

## Model predicting choices across conditions

```{r}

df.tbt.c <- subset(df.tbt.c, ID != 216) # remove outliers
df.tbt.c <- subset(df.tbt.c, ID != 253)

glmer.tbt.corr <- glmer(choice ~ trialno*agent*group + (1 + trialno*agent|ID), data = df.tbt.c, family = binomial, contrasts = NULL, glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))

performstats <- stats.rlmerMod.f(glmer.tbt.corr)

row.names(performstats) <- c("Intercept", "Trial number", "Agent (other vs self)", "Agent (no one vs self)", "Group (older vs younger)", "Trial number * agent (other vs self)", "Trial number * agent (no one vs self)", "Trial number * group", "Group * agent (other vs self)", "Group * agent (no one vs self)", "Trial number * group * agent (other vs self)", "Trial number * group * agent (no one vs self)")
kable(performstats,
      align = rep('c',6),
      caption = "Robust linear mixed model for choice performance") %>% kable_styling()

```

## Analysis of RL parameters from model with 3 alphas, 1 beta

```{r}

## Load and organise the data

df.full <- read_xlsx("PL_152_combined_data_share.xlsx", sheet = 1, col_names = T) 

df.full <- df.full %>%
  mutate(Gender = factor(Gender,
                         levels = c(1,2),
                         labels = c("male", "female")))     %>% # factorise gender with text labels
  mutate(Group = factor(Group))                            %>% # factorise group keeping numbers
  mutate(group = factor(Group, 
                        levels = c(1,2), 
                        labels = c("young", "old")))        %>% # factorise group with text labels
  mutate(ID = factor(ID_Code, ordered=F))                        # factorise ID

# rename columns to use in creating long format (self: agent1, other: agent2, no one: agent3)

df.full <- rename(df.full, c("PL_self_alpha"="agent1-alpha", "PL_other_alpha"="agent2-alpha", "PL_noone_alpha"="agent3-alpha"))
df.full <- rename(df.full, c("PL_self_corr"="agent1-corr", "PL_other_corr"="agent2-corr", "PL_noone_corr"="agent3-corr"))

# make performance a percentage (0-100) instead of a proportion (0-1)

df.full$`agent1-corr` <- df.full$`agent1-corr`*100
df.full$`agent2-corr` <- df.full$`agent2-corr`*100
df.full$`agent3-corr` <- df.full$`agent3-corr`*100

# z score traits separately for each group

df.full$SRP_affective_interpersonal_z <- NA
df.full$SRP_affective_interpersonal_z[df.full$group == "young"] <- scale(df.full$SRP_affective_interpersonal[df.full$group == "young"])
df.full$SRP_affective_interpersonal_z[df.full$group == "old"] <- scale(df.full$SRP_affective_interpersonal[df.full$group == "old"])

df.full$SRP_lifestyle_antisocial_z <- NA
df.full$SRP_lifestyle_antisocial_z[df.full$group == "young"] <- scale(df.full$SRP_lifestyle_antisocial[df.full$group == "young"])
df.full$SRP_lifestyle_antisocial_z[df.full$group == "old"] <- scale(df.full$SRP_lifestyle_antisocial[df.full$group == "old"])

# create long data format

df.l <- df.full                                                             %>%
  tidyr::pivot_longer(
    starts_with("agent"),
    names_to = c("agent", ".value"),
    names_sep = "-",
  )                                                                         %>% # long format
  drop_na("alpha")                                                          %>% # remove 2 participants excluded for outlier alpha values
  mutate(agent = factor(agent, 
                        levels = c("agent1", "agent2", "agent3"),
                        labels = c("self", "other", "noone"), ordered=F))   %>% # factorise agent (self as reference group)
  mutate(group = factor(Group, 
                        levels = c(1,2), 
                        labels = c("young", "old")))                        %>% # factorise group
  mutate(ID = factor(ID_Code, ordered=F))                                   %>% # factorise ID
  mutate(condition = interaction(agent, group, sep = ":"))                      # create column with the interaction between group and agent

```

```{r}

## Demographics

demographics <- df.full %>%
  dplyr::select(contains("Group", ignore.case = F), matches("Age", ignore.case = F), contains("Education_years"), matches("Gender", ignore.case = F)) %>%
  dplyr::group_by(Group) 

d.mean <- demographics %>%
  dplyr::summarise_if(is.numeric, list(mean = mean), na.rm = T) 
d.min <- demographics %>%
  dplyr::summarise_if(is.numeric, list(min = min), na.rm = T)
d.max <- demographics %>%
  dplyr::summarise_if(is.numeric, list(max = max), na.rm = T)
d.sd <- demographics %>%
  dplyr::summarise_if(is.numeric, list(sd = sd), na.rm = T)
d.n <- demographics %>%
  dplyr::summarise(n = n())
d.gender <- as.data.frame.matrix(table(demographics$Group, demographics$Gender))

d <- bind_cols(d.mean, d.min[2:3], d.max[2:3], d.sd[2:3], d.n[2], d.gender)

diff.gender <- chisq.test(d.gender)
diff.education <- wilcox.test(
  df.full$Education_years[df.full$group == "young"],
  df.full$Education_years[df.full$group == "old"],
  paired = FALSE)

Z.stat.education <- qnorm(diff.education$p.value/2)

diff.education.es <- df.full %>% wilcox_effsize(Education_years ~ group, ci = TRUE)

```

```{r}

## Plot histograms and check skew & kurtosis

hist(df.full$`agent1-alpha`)
hist(df.full$`agent2-alpha`)
hist(df.full$`agent3-alpha`)
hist(df.full$beta_152)
hist(df.full$SRP_affective_interpersonal)
hist(df.full$SRP_lifestyle_antisocial)
hist(df.full$Education_years)

describe(df.full$`agent1-alpha`) # skew > 1.4, kurtosis > 1.75 **
describe(df.full$`agent2-alpha`) # skew = 0, kurtosis < .1 (use robust to match other alphas)
describe(df.full$`agent3-alpha`) # skew > 1.6, kurtosis > 3.85 **
describe(df.full$beta_152) # skew > 1.8, kurtosis > 2.8 **
describe(df.full$SRP_affective_interpersonal) # skew > 1.77, kurtosis > 4.07 **
describe(df.full$SRP_lifestyle_antisocial) # skew > 1.61, kurtosis > 3.11 **

```

## Model of alpha

```{r}

## Use robust linear mixed effects models to analyse the data due to heavily skewed distribution

rlmermodel <- rlmer(alpha ~ agent*group + (1|ID), data = df.l)

# Pull out stats
alphastats <- stats.rlmerMod.f(rlmermodel)

if (alphastats["agentother:groupold","p"] < .05) { ph.sig.a <- "*" 
} else if (alphastats["agentother:groupold","p"] >= .05) { ph.sig.a <- NA } 

row.names(alphastats) <- c("Intercept", "Agent (other vs self)", "Agent (no one vs self)", "Group (older vs younger)", "Group * agent (other vs self)", "Group * agent (no one vs self)")
kable(alphastats,
      align = rep('c',6),
      caption = "Robust linear mixed model for learning rates") %>% kable_styling()

```

## Post hocs

## Wilcoxon signed rank test on self, other and noone parameters for each group separately

```{r}

df.full <- df.full %>% drop_na("agent1-alpha")

Zstat.young.so <- list()
Zstat.young.sn <- list()
Zstat.young.on <- list()
Zstat.older.so <- list()
Zstat.older.sn <- list()
Zstat.older.on <- list()
Zstat.self <- list()
Zstat.other <- list()
Zstat.noone <- list()

vars <- c("alpha")
names <- c("learning rate")
ph.sig <- array(NA,c(6,9))
v <- 1

i <- vars[v]

outcomes <- df.l %>%
  dplyr::select(contains(i), contains("group"), contains("agent"))
names(outcomes)[names(outcomes) == i] <- "outcome"

# younger group, self vs other
wil.young.so <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "other"], 
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "self"],  
  paired = TRUE, conf.int = TRUE)

# younger group, self vs noone
wil.young.sn <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "noone"],
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "self"],
  paired = TRUE, conf.int = TRUE)

# younger group, other vs noone
wil.young.on <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "noone"],
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "other"],
  paired = TRUE, conf.int = TRUE)

# older group, self vs other
wil.old.so <- wilcox.test(
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "other"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "self"],
  paired = TRUE)

# older group, self vs noone
wil.old.sn <- wilcox.test(
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "noone"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "self"],
  paired = TRUE)

# older group, other vs noone
wil.old.on <- wilcox.test(
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "noone"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "other"],
  paired = TRUE)

# self, young vs older
wil.self <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent == "self"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "self"],
  paired = FALSE)

# other, young vs older
wil.other <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent== "other"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "other"],
  paired = FALSE)

# noone, young vs older
wil.noone <- wilcox.test(
  outcomes$outcome[outcomes$group == "young" & outcomes$agent== "noone"],
  outcomes$outcome[outcomes$group == "old" & outcomes$agent == "noone"],
  paired = FALSE)

# calculate the z statistic

Zstat.young.so[v] <- qnorm(wil.young.so$p.value/2)
Zstat.young.sn[v] <- qnorm(wil.young.sn$p.value/2)
Zstat.young.on[v] <- qnorm(wil.young.on$p.value/2)
Zstat.older.so[v] <- qnorm(wil.old.so$p.value/2)
Zstat.older.sn[v] <- qnorm(wil.old.sn$p.value/2)
Zstat.older.on[v] <- qnorm(wil.old.on$p.value/2)
Zstat.self[v]  <- qnorm(wil.self$p.value/2)
Zstat.other[v] <- qnorm(wil.other$p.value/2)
Zstat.noone[v] <- qnorm(wil.noone$p.value/2)


# 

if (wil.self$p.value < .05) { ph.sig[v,1] <- "*" 
} else if (wil.self$p.value >= .05) { ph.sig[v,1] <- NA } 
if (wil.other$p.value < .05) { ph.sig[v,2] <- "*" 
} else if (wil.other$p.value >= .05) { ph.sig[v,2] <- NA }
if (wil.noone$p.value < .05) { ph.sig[v,3] <- "*" 
} else if (wil.noone$p.value >= .05) { ph.sig[v,3] <- NA } 

if (wil.young.so$p.value < .05) { ph.sig[v,4] <- "*" 
} else if (wil.young.so$p.value >= .05) {ph.sig[v,4] <- NA } 
if (wil.young.on$p.value < .05) { ph.sig[v,5] <- "*" 
} else if (wil.young.on$p.value >= .05) {ph.sig[v,5] <- NA } 
if (wil.young.sn$p.value < .05) { ph.sig[v,6] <- "*" 
} else if (wil.young.sn$p.value >= .05) {ph.sig[v,6] <- NA }
if (wil.old.so$p.value < .05) { ph.sig[v,7] <- "*" 
} else if (wil.old.so$p.value >= .05) {ph.sig[v,7] <- NA } 
if (wil.old.on$p.value < .05) { ph.sig[v,8] <- "*" 
} else if (wil.old.on$p.value >= .05) {ph.sig[v,8] <- NA } 
if (wil.old.sn$p.value < .05) { ph.sig[v,9] <- "*" 
} else if (wil.old.sn$p.value >= .05) {ph.sig[v,9] <- NA }

sig.order <- c("self","other","noone","y s-o","y o-n","y s-n","o s-o","o o-n","o s-n") # should match order above

colnames(ph.sig) <- sig.order

# table of group tests

table.t <- paste0(vars[i], " for...")

wil.group.table <- tibble(
  'Group' = c("Self", "Other", "No one"),
  'Young mean' = c(
    mean(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "self"]),
    mean(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "other"]),
    mean(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "noone"])),
  'Young SD' = c(
    sd(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "self"]),
    sd(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "other"]),
    sd(outcomes$outcome[outcomes$group == "young" & outcomes$agent == "noone"])),
  'Older mean' = c(
    mean(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "self"], na.rm = T),
    mean(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "other"], na.rm = T),
    mean(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "noone"], na.rm = T)),
  'Older SD' = c(
    sd(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "self"], na.rm = T),
    sd(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "other"], na.rm = T),
    sd(outcomes$outcome[outcomes$group == "old" & outcomes$agent == "noone"], na.rm = T)),
  z = c(round(Zstat.self[[v]],2), round(Zstat.other[[v]],2), round(Zstat.noone[[v]],2)),
  #df = 
  p = c(pvalr(wil.self$p.value), pvalr(wil.other$p.value), pvalr(wil.noone$p.value))
)

kable(wil.group.table,
      digits = 4,
      align = c('l', rep('c',6)),
      caption = paste0("Differences between groups in ", names[v], " for each agent")) %>% kable_styling()

wil.agent.table <- tibble(
  'Comparison' = c("Self vs. other", "Self vs. no one", "Other vs. no one"),
  'Young z' = c(round(Zstat.young.so[[v]],2), round(Zstat.young.sn[[v]],2), round(Zstat.young.on[[v]],2)),
  'Young p' = c(pvalr(wil.young.so$p.value), pvalr(wil.young.sn$p.value), pvalr(wil.young.on$p.value)),
  'Older z' = c(round(Zstat.older.so[[v]],2), round(Zstat.older.sn[[v]],2), round(Zstat.older.on[[v]],2)),
  'Older p' = c(pvalr(wil.old.so$p.value), pvalr(wil.old.sn$p.value), pvalr(wil.old.on$p.value))
)

kable(wil.agent.table,
      digits = 4,
      align = c('l', rep('c',4)),
      caption = paste0("Differences between agents in ", names[v], " for each group")) %>% kable_styling()

wil.self.es <- df.full %>% wilcox_effsize(`agent1-alpha` ~ group, ci = TRUE)
wil.other.es <- df.full %>% wilcox_effsize(`agent2-alpha` ~ group, ci = TRUE)
wil.noone.es <- df.full %>% wilcox_effsize(`agent3-alpha` ~ group, ci = TRUE)

wil.young.es <- subset(df.l, group == "young") %>% 
  wilcox_effsize(alpha ~ agent, ci = TRUE, paired = TRUE)

wil.old.es <- subset(df.l, group == "old") %>% 
  wilcox_effsize(alpha ~ agent, ci = TRUE, paired = TRUE)

## Wilcoxon signed rank test on betas

df.full <- df.full %>% drop_na("beta_152")

## comparison of betas, young vs older
wil.beta <- wilcox.test(
  df.full$beta_152[df.full$group == "young"],
  df.full$beta_152[df.full$group == "old"],
  paired = FALSE)

if (wil.beta$p.value < .05) { ph.sig.b <- "*" 
} else if (wil.beta$p.value >= .05) { ph.sig.b <- NA } 

Zstat.beta <- qnorm(wil.beta$p.value/2)

wil.beta.es <- df.full %>% wilcox_effsize(beta_152 ~ group, ci = TRUE)

```

## Differences between young and old on psychopathy

```{r}

df.full.srp <- df.full %>% drop_na("agent1-alpha") %>% 
  drop_na("SRP_affective_interpersonal")

# SRP affective interpersonal, young vs older
diff.srp.ai <- wilcox.test(
  df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "young"],
  df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "old"],
  paired = FALSE)

if (diff.srp.ai$p.value < .05) { ph.sig.ai <- "*" 
} else if (diff.srp.ai$p.value >= .05) { ph.sig.ai <- NA } 

wil.srp.ai.es <- df.full.srp %>% wilcox_effsize(SRP_affective_interpersonal ~ group, ci = TRUE)

# SRP lifestyle antisocial, young vs older
diff.srp.la <- wilcox.test(
  df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "young"],
  df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "old"],
  paired = FALSE)

if (diff.srp.la$p.value < .05) { ph.sig.la <- "*" 
} else if (diff.srp.la$p.value >= .05) { ph.sig.la <- NA } 

wil.srp.la.es <- df.full.srp %>% wilcox_effsize(SRP_lifestyle_antisocial ~ group, ci = TRUE)

# calculate the z statistic

Zstat.srp.ai  <- qnorm(diff.srp.ai$p.value/2)
Zstat.srp.la  <- qnorm(diff.srp.la$p.value/2)  

n.young = c(
  length(which(!is.na(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "young"]))),    
  length(which(!is.na(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "young"]))))

n.old = c(
  length(which(!is.na(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "old"]))),    
  length(which(!is.na(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "old"]))))

# table of group tests

id.diff.table <- tibble(
  'Questionnaire:' = c("SRP affective interpersonal", "SRP lifestyle antisocial"),
  'Young mean (s.d)' = c(
    paste0(round(mean(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "young"], na.rm = T),2),' (',round(sd(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "young"], na.rm = T),2),')'),
    paste0(round(mean(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "young"], na.rm = T),2),' (',round(sd(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "young"], na.rm = T),2),')')),
  'Older mean (s.d)' = c(
    paste0(round(mean(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "old"], na.rm = T),2),' (',round(sd(df.full.srp$SRP_affective_interpersonal[df.full.srp$group == "old"], na.rm = T),2),')'),
    paste0(round(mean(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "old"], na.rm = T),2),' (',round(sd(df.full.srp$SRP_lifestyle_antisocial[df.full.srp$group == "old"], na.rm = T),2),')')),
  Z = c(round(Zstat.srp.ai,2), round(Zstat.srp.la,2)),
  p = pvalr(c(diff.srp.ai$p.value, diff.srp.la$p.value))
)

kable(id.diff.table,
      align = c('l', rep('c',5)),
      caption = "Differences between groups in trait measures") %>% kable_styling()

```

## Correlations between traits and learning parameters

```{r}

# SRP - affective interpersonal & alphas

corr.young.self.ai <- 
  rcorr(df.full$`agent1-alpha`[df.full$Group == 1],
        df.full$SRP_affective_interpersonal[df.full$Group == 1],
        type = "spearman")

corr.young.other.ai <- 
  rcorr(df.full$`agent2-alpha`[df.full$Group == 1],
        df.full$SRP_affective_interpersonal[df.full$Group == 1],
        type = "spearman")

corr.young.noone.ai <- 
  rcorr(df.full$`agent3-alpha`[df.full$Group == 1],
        df.full$SRP_affective_interpersonal[df.full$Group == 1],
        type = "spearman")

corr.young.otherself.ai <- 
  rcorr(df.full$`other-self_alph`[df.full$Group == 1],
        df.full$SRP_affective_interpersonal[df.full$Group == 1],
        type = "spearman")

corr.old.self.ai <- 
  rcorr(df.full$`agent1-alpha`[df.full$Group == 2],
        df.full$SRP_affective_interpersonal[df.full$Group == 2],
        type = "spearman")

corr.old.other.ai <- 
  rcorr(df.full$`agent2-alpha`[df.full$Group == 2],
        df.full$SRP_affective_interpersonal[df.full$Group == 2],
        type = "spearman")

corr.old.noone.ai <- 
  rcorr(df.full$`agent3-alpha`[df.full$Group == 2],
        df.full$SRP_affective_interpersonal[df.full$Group == 2],
        type = "spearman")

corr.old.otherself.ai <- 
  rcorr(df.full$`other-self_alph`[df.full$Group == 2],
        df.full$SRP_affective_interpersonal[df.full$Group == 2],
        type = "spearman")

# table of these correlations 

corr.table.ai <- tibble(
  Group = c("Young", "Young", "Young", "Young", "Older", "Older", "Older", "Older"),
  Agent = rep(c("Self", "Other", "No one", "Other - self"), 2),
  r = c(corr.young.self.ai$r[1,2],
        corr.young.other.ai$r[1,2],
        corr.young.noone.ai$r[1,2],        
        corr.young.otherself.ai$r[1,2],
        corr.old.self.ai$r[1,2],
        corr.old.other.ai$r[1,2],
        corr.old.noone.ai$r[1,2],
        corr.old.otherself.ai$r[1,2]),
  p = c(corr.young.self.ai$P[1,2],
        corr.young.other.ai$P[1,2],
        corr.young.noone.ai$P[1,2],
        corr.young.otherself.ai$P[1,2],
        corr.old.self.ai$P[1,2],
        corr.old.other.ai$P[1,2],
        corr.old.noone.ai$P[1,2],        
        corr.old.otherself.ai$P[1,2])
)

kable(corr.table.ai, caption = 
        "Correlations between alphas and affective interpersonal" ) %>%
  kable_styling() 

# confidence intervals

corr.young.self.ai.ci <- 
  corr.test(df.full$`agent1-alpha`[df.full$Group == 1],
            df.full$SRP_affective_interpersonal[df.full$Group == 1],
            method = "spearman")

corr.young.other.ai.ci <- 
  corr.test(df.full$`agent2-alpha`[df.full$Group == 1],
            df.full$SRP_affective_interpersonal[df.full$Group == 1],
            method = "spearman")

corr.young.noone.ai.ci <- 
  corr.test(df.full$`agent3-alpha`[df.full$Group == 1],
            df.full$SRP_affective_interpersonal[df.full$Group == 1],
            method = "spearman")

corr.young.otherself.ai.ci <- 
  corr.test(df.full$`other-self_alph`[df.full$Group == 1],
            df.full$SRP_affective_interpersonal[df.full$Group == 1],
            method = "spearman")

corr.old.self.ai.ci <- 
  corr.test(df.full$`agent1-alpha`[df.full$Group == 2],
            df.full$SRP_affective_interpersonal[df.full$Group == 2],
            method = "spearman")

corr.old.other.ai.ci <- 
  corr.test(df.full$`agent2-alpha`[df.full$Group == 2],
            df.full$SRP_affective_interpersonal[df.full$Group == 2],
            method = "spearman")

corr.old.noone.ai.ci <- 
  corr.test(df.full$`agent3-alpha`[df.full$Group == 2],
            df.full$SRP_affective_interpersonal[df.full$Group == 2],
            method = "spearman")

corr.old.otherself.ai.ci <- 
  corr.test(df.full$`other-self_alph`[df.full$Group == 2],
            df.full$SRP_affective_interpersonal[df.full$Group == 2],
            method = "spearman")



# partial correlations

df.full.pcorr <- df.full %>% tidyr::drop_na("agent2-alpha", "SRP_affective_interpersonal", "beta_152")

pcorr.young.other.ai <- pcor.test(df.full.pcorr$`agent2-alpha`[df.full.pcorr$Group == 1],
                                  df.full.pcorr$SRP_affective_interpersonal[df.full.pcorr$Group == 1],
                                  df.full.pcorr$beta_152[df.full.pcorr$Group == 1], 
                                  method = "spearman")

pcorr.old.other.ai <- pcor.test(df.full.pcorr$`agent2-alpha`[df.full.pcorr$Group == 2],
                                df.full.pcorr$SRP_affective_interpersonal[df.full.pcorr$Group == 2],
                                df.full.pcorr$beta_152[df.full.pcorr$Group == 2], 
                                method = "spearman")

pcorr.young.os.ai <- pcor.test(df.full.pcorr$`other-self_alph`[df.full.pcorr$Group == 1],
                               df.full.pcorr$SRP_affective_interpersonal[df.full.pcorr$Group == 1],
                               df.full.pcorr$beta_152[df.full.pcorr$Group == 1], 
                               method = "spearman")

pcorr.old.os.ai <- pcor.test(df.full.pcorr$`other-self_alph`[df.full.pcorr$Group == 2],
                             df.full.pcorr$SRP_affective_interpersonal[df.full.pcorr$Group == 2],
                             df.full.pcorr$beta_152[df.full.pcorr$Group == 2], 
                             method = "spearman")


# test for differences in correlations between young and old

r.other.ai <- paired.r(corr.young.other.ai$r[1,2], corr.old.other.ai$r[1,2], n = 74, n2 = 74)
r.otherself.ai <- paired.r(corr.young.otherself.ai$r[1,2], corr.old.otherself.ai$r[1,2], n = 74, n2 = 74)
pr.other.ai <- paired.r(pcorr.young.other.ai$estimate, pcorr.old.other.ai$estimate, n = 74, n2 = 74)
pr.otherself.ai <- paired.r(pcorr.young.os.ai$estimate, pcorr.old.os.ai$estimate, n = 74, n2 = 74)

```

## Plots of main effects

```{r}

titles <- c("Learning rate (\u03B1)")
names <- c("Alpha")

pltorder <- c(1:6)

interactionlims <- c('self:young', 'other:young', 'noone:young', 'self:old', 'other:old', 'noone:old')
interactionlabs <- c('Young (self)', 'Young (other)', 'Young (no one)', 'Older (self)', 'Older (other)', 'Older (no one)')
interactionlabs <- c('', '', '   Young', '', '', '   Older') # just once for legend with columns
interactionalpha <- c(1, 1, 1, 0.33, 0.33, 0.33)

lims <- c(0, NA)

bar3cols <- c('#365F91', '#3C859A', '#60487A', '#365F91', '#3C859A', '#60487A') # [self, other, no one] * 2 as graph applies alpha to older bars
inddata3cols <-c('#90A8C3', '#96BCC8', '#AA9CB7', '#90A8C3', '#96BCC8', '#AA9CB7') # [self, other, no one] * 2 as same for young and older

# Greys
bar1col <- c('#767171', '#767171') # e.g. other - self alpha
inddata1cols <- c('#A8A5A5', '#A8A5A5')

interactionlims <- interactionlims[pltorder]
interactionlabs <- interactionlabs[pltorder]
interactionalpha <- interactionalpha[pltorder]
bar3cols <- bar3cols[pltorder]
inddata3cols <- inddata3cols[pltorder]

# Bar plot of medians

medplotW <- plotH * 1.3

for (v in 1) {
  
  i <- vars[v]
  t <- titles[v]
  n <- names[v]
  
  graphname <- paste0('Plots/',n,'_by_group_wsig.tiff')
  if (saveplots == 1) {tiff(graphname, units="in", width=medplotW, height=plotH, res=resolution)}
  
  ## Organise data to get standard errors
  plt.data <- df.l %>%
    dplyr::group_by(agent, group, condition) %>%
    dplyr::summarise(n = n(), median = median(get(i),na.rm=T), sd = sd(get(i),na.rm=T), se = sd/sqrt(n))
  
  plt <- ggplot(plt.data, aes(x=agent, y=median, group = condition, fill = condition, color = condition, alpha = condition)) +
    geom_bar(stat= "identity", position=position_dodge(0.75), width = 0.75, size = 0.4, color = 'black') +
    geom_jitter(data = df.l, aes(x = agent, y = get(i), group = condition, color = condition), position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.05), size = 2, alpha = 0.3, show.legend = FALSE) +
    geom_bar(stat= "identity", position=position_dodge(0.75), width = 0.75, size = 0.4, alpha = 0, color = 'black') +
    geom_errorbar(aes(ymin = median-se, ymax = median+se), position=position_dodge(.75), color = 'black', width = 0, alpha = 1) +
    scale_x_discrete(labels = c('Self', 'Other', 'No one')) + 
    scale_y_continuous(limits = lims, expan = expand_scale(mult = c(0, .1))) +
    labs(x= NULL,
         y = t) +
    scale_fill_manual(name = "condition", limits = interactionlims, values = bar3cols, labels = interactionlabs) +
    scale_color_manual(name = "condition", limits = interactionlims, values = inddata3cols, labels = interactionlabs) +
    scale_alpha_manual(name = "condition", limits = interactionlims, values = interactionalpha, labels = interactionlabs) +
    theme_classic() +
    theme(legend.title = element_blank(),
          legend.key = element_rect(size = c(3,2), color = NA),
          axis.text.x=element_text(size = axtitle, hjust = c(0.65,0.55,0.3), colour = "black"), 
          axis.text.y=element_text(size = axtext), 
          axis.title=element_text(size = axtitle), 
          legend.text = element_text(size = axtitle),
          legend.spacing.x = unit(-0.03,'cm'),
          legend.key.height = unit(1,'cm'),
          legend.key.width = unit(0.5,'cm')) +
    guides(fill=guide_legend(ncol=3, byrow = TRUE), color=guide_legend(ncol=3, byrow = TRUE))
  
  r <- 1.5 * (max(ggplot_build(plt)$data[[1]]$x) / max(ggplot_build(plt)$data[[2]]$y, na.rm = T))
  if (v == 6) {r <- r/2}
  plt <- plt + coord_fixed(ratio = r, expand = T)
  
  # print(plt) # with legend, no significance
  
  linespace <- c(max(ggplot_build(plt)$data[[1]]$y, na.rm = T), max(ggplot_build(plt)$data[[2]]$y, na.rm = T))
  if (sum(!is.na(ph.sig[v,4:9])) == 0) {increments <- ((linespace[2] - linespace[1]) / 2)}
  else {increments <- (linespace[2] - linespace[1]) / (sum(!is.na(ph.sig[v,4:9])) + 1)}
  ypos <- linespace[1] + increments
  xpoints <- array(NA,c(9,2))
  rownames(xpoints) <- sig.order
  xpoints[1,1:2] <- ggplot_build(plt)$data[[1]]$x[1:2]
  xpoints[2,1:2] <- ggplot_build(plt)$data[[1]]$x[3:4]
  xpoints[3,1:2] <- ggplot_build(plt)$data[[1]]$x[5:6]
  xpoints[4,1:2] <- ggplot_build(plt)$data[[1]]$x[c(1,3)]
  xpoints[5,1:2] <- ggplot_build(plt)$data[[1]]$x[c(3,5)]
  xpoints[6,1:2] <- ggplot_build(plt)$data[[1]]$x[c(1,5)]  
  xpoints[7,1:2] <- ggplot_build(plt)$data[[1]]$x[c(2,4)]
  xpoints[8,1:2] <- ggplot_build(plt)$data[[1]]$x[c(4,6)]
  xpoints[9,1:2] <- ggplot_build(plt)$data[[1]]$x[c(2,6)]
  for (tstar in 1:9) {
    if (is.na(ph.sig[v,tstar]) == FALSE) {
      if (tstar > 3) {
        ypos <- ypos + increments 
      }
      plt <- plt +
        geom_signif(annotation = ph.sig[v,tstar], y_position = ypos, xmin = xpoints[tstar,1], xmax = xpoints[tstar,2], tip_length = 0, color = 'black', alpha = 1)
    }
  }
  
  print(plt) # no legend, with significance
  if (saveplots == 1) {dev.off()}
  
}

# Bar plot of other - self alpha

osplotW <- plotH * 0.7
n <- "O-S_alpha"
lims <- c(NA, NA)

graphname <- paste0('Plots/',n,'_by_group_wsig.tiff')
if (saveplots == 1) {tiff(graphname, units="in", width=osplotW, height=plotH, res=resolution)}

## Organise data to get standard errors
plt.data <- df.full %>%
  dplyr::group_by(group) %>%
  dplyr::summarise(n = n(), median = median(`other-self_alph`,na.rm=T), sd = sd(`other-self_alph`,na.rm=T), se = sd/sqrt(n))

plt <- ggplot(plt.data, aes(x=group, y=median, alpha = group)) +
  geom_bar(stat= "identity", width = 0.5, size = 0.4, color = 'black', fill = bar1col) +
  geom_jitter(data = df.full, aes(x = group, y = `other-self_alph`, color = group), position = position_jitterdodge(dodge.width = 0.5, jitter.height = 0, jitter.width = 0.05), size = 2, alpha = 0.3) +
  geom_bar(stat= "identity", width = 0.5, size = 0.4, alpha = 0, color = 'black') +
  geom_errorbar(aes(ymin = median-se, ymax = median+se), position=position_dodge(0), color = 'black', width = 0, alpha = 1) +
  scale_x_discrete(labels = c('Young', 'Older')) + 
  scale_y_continuous(limits = lims, expand = expand_scale(mult = c(0, .12))) +
  labs(x= NULL,
       y = "\u03B1<sub>other</sub> - \u03B1<sub>self</sub><br>") +
  scale_fill_manual(values = bar1col, labels = c('Young', 'Older')) +
  scale_color_manual(values = inddata1cols, labels = c('Young', 'Older')) +
  scale_alpha_manual(values = c(1, 0.33), labels = c('Young', 'Older')) +
  theme_classic() +
  theme(legend.title = element_blank()) + 
  theme(axis.text.x=element_text(size = axtitle, hjust = c(0.7,0.3), colour = "black"), 
        axis.text.y=element_text(size = axtext), 
        axis.title.y=element_markdown(size = axtitle)) +
  theme(legend.position = 'none') #+ 
#annotation_custom(grob = textGrob("more self-bias", x=-0.5,  y=0.2, rot = 90,
#  gp=gpar(fontsize=14, fontface="italic"))) +
#annotation_custom(grob = textGrob("more prosocial", x=-0.5,  y=0.8, rot = 90,
#  gp=gpar(fontsize=14, fontface="italic")))

r <- 3 * (max(ggplot_build(plt)$data[[1]]$x) / ((max(ggplot_build(plt)$data[[2]]$y, na.rm = T)) + (-1*(min(ggplot_build(plt)$data[[2]]$y, na.rm = T))))) 
plt <- plt + coord_fixed(ratio = r, expand = T, clip = 'off') 

# print(plt) # no legend, no significance

if (ph.sig.a == "*") {
  linespace <- c(max(ggplot_build(plt)$data[[1]]$y, na.rm = T), max(ggplot_build(plt)$data[[2]]$y, na.rm = T))
  increments <- (linespace[2] - linespace[1]) / 2
  ypos <- linespace[1] + increments
  xpoints <- rev(ggplot_build(plt)$data[[1]]$x[1:2])
  
  plt <- plt +
    geom_signif(annotation = ph.sig.a, y_position = ypos, xmin = xpoints[1], xmax = xpoints[2], tip_length = 0, color = 'black', alpha = 1)
  
} 

print(plt) # no legend, with significance
if (saveplots == 1) {dev.off()}

```

## Plots of correlations

```{r}

selfcorcols <- c('#365F91', '#6EB3E4')
othercorcols <- c('#3C859A', '#009E99')
noonecorcols <- c('#60487A', '#7D30A0')
oscorcols <- othercorcols

corrplotH <- plotH
corrplotW <- plotH * 1.625
axtext <- 16

## Plots of alpha with SRP psychopathy affective interpersonal subscale

# plot self; dotplot of learning rate vs score on SRP affective interpersonal subscale
# line of best fit; colour indicates age (young vs old)

if (saveplots == 1) {tiff("Plots/SRP_ai_vs_alpha_self.tiff", units="in", width = corrplotW, height = corrplotH, res = resolution)}

plot.self.ai <- ggplot(df.full, aes(x = `agent1-alpha`, y = SRP_affective_interpersonal)) + 
  geom_point(aes(color = group, shape = group, alpha = group), size = 2, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0, size = 0.75) +
  scale_x_continuous(name = paste0("\u03B1","<sub>self</sub>"), n.breaks = 3) +
  scale_y_continuous(name = "Trait psychopathy<br>
        <span style='font-size:14pt'>(Affective interpersonal subscale)</span>", breaks = seq(10, 60, 10)) + 
  coord_cartesian(ylim=c(10, 60)) + 
  scale_fill_manual(values = selfcorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_color_manual(values = selfcorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_linetype_manual(values = c("solid", "twodash"), labels = c('Young', 'Older'), name = "Group") +
  scale_shape_manual(values = c(20,18), labels = c('Young', 'Older'), name = "Group") +
  scale_alpha_manual(values = c(0.3,0.3), labels = c('Young', 'Older'), name = "Group") +
  theme_classic() + 
  theme(legend.title = element_blank(), legend.text = element_text(size = axtext), legend.key.size = unit(3,"line")) + 
  theme(axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 2)))

plot.self.ai

if (saveplots == 1) {dev.off()}

# plot other; dotplot of learning rate vs score on SRP affective interpersonal subscale
# line of best fit; colour indicates age (young vs old)

if (saveplots == 1) {tiff("Plots/SRP_ai_vs_alpha_other.tiff", units="in", width = corrplotW, height = corrplotH, res = resolution)}

plot.other.ai <- ggplot(df.full, aes(x = `agent2-alpha`, y = SRP_affective_interpersonal)) + 
  geom_point(aes(color = group, shape = group, alpha = group), size = 2, show.legend = FALSE) +  
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) +  
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0, size = 0.75) +
  scale_x_continuous(name = paste0("\u03B1","<sub>other</sub>"), n.breaks = 5) +
  scale_y_continuous(name = "Trait psychopathy<br>
        <span style='font-size:14pt'>(Affective interpersonal subscale)</span>", breaks = seq(10, 60, 10)) + 
  coord_cartesian(ylim=c(10, 60)) + 
  scale_fill_manual(values = othercorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_color_manual(values = othercorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_linetype_manual(values = c("solid", "twodash"), labels = c('Young', 'Older'), name = "Group") +
  scale_shape_manual(values = c(20,18), labels = c('Young', 'Older'), name = "Group") +
  scale_alpha_manual(values = c(0.3,0.3), labels = c('Young', 'Older'), name = "Group") +
  theme_classic() + 
  theme(legend.title = element_blank(), legend.text = element_text(size = axtext), legend.key.size = unit(3,"line")) + 
  theme(axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 2)))

plot.other.ai

if (saveplots == 1) {dev.off()}

# plot no one; dotplot of learning rate vs score on SRP affective interpersonal subscale
# line of best fit; colour indicates age (young vs old)

if (saveplots == 1) {tiff("Plots/SRP_ai_vs_alpha_noone.tiff", units="in", width = corrplotW, height = corrplotH, res = resolution)}

plot.noone.ai <- ggplot(df.full, aes(x = `agent3-alpha`, y = SRP_affective_interpersonal)) + 
  geom_point(aes(color = group, shape = group, alpha = group), size = 2, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0, size = 0.75) +
  scale_x_continuous(name = paste0("\u03B1","<sub>no one</sub>"), n.breaks = 3) +
  scale_y_continuous(name = "Trait psychopathy<br>
        <span style='font-size:14pt'>(Affective interpersonal subscale)</span>", breaks = seq(10, 60, 10)) + 
  coord_cartesian(ylim=c(10, 60)) + 
  scale_fill_manual(values = noonecorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_color_manual(values = noonecorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_linetype_manual(values = c("solid", "twodash"), labels = c('Young', 'Older'), name = "Group") +
  scale_shape_manual(values = c(20,18), labels = c('Young', 'Older'), name = "Group") +
  scale_alpha_manual(values = c(0.3,0.3), labels = c('Young', 'Older'), name = "Group") +
  theme_classic() + 
  theme(legend.title = element_blank(), legend.text = element_text(size = axtext), legend.key.size = unit(3,"line")) + 
  theme(axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 2)))

plot.noone.ai

if (saveplots == 1) {dev.off()}

# plot other - self; dotplot of learning rate vs score on SRP affective interpersonal subscale
# line of best fit; colour indicates age (young vs old)

if (saveplots == 1) {tiff("Plots/SRP_ai_vs_alpha_o-s.tiff", units="in", width = corrplotW, height = corrplotH, res = resolution)}

plot.otherself.ai <- ggplot(df.full, aes(x = `other-self_alph`, y = SRP_affective_interpersonal)) + 
  geom_point(aes(color = group, shape = group, alpha = group), size = 2, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(aes(group = group, color = group, fill = group, linetype = group), method = 'lm', alpha = 0, size = 0.75) +
  scale_x_continuous(name = paste0("\u03B1","<sub>other</sub> - ","\u03B1","<sub>self</sub>"), n.breaks = 4) +
  scale_y_continuous(name = "Trait psychopathy<br>
        <span style='font-size:14pt'>(Affective interpersonal subscale)</span>", breaks = seq(10, 60, 10)) + 
  coord_cartesian(ylim=c(10, 60)) + 
  scale_fill_manual(values = oscorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_color_manual(values = oscorcols, labels = c('Young', 'Older'), name = "Group") + 
  scale_linetype_manual(values = c("solid", "twodash"), labels = c('Young', 'Older'), name = "Group") +
  scale_shape_manual(values = c(20,18), labels = c('Young', 'Older'), name = "Group") +
  scale_alpha_manual(values = c(0.3,0.3), labels = c('Young', 'Older'), name = "Group") +
  theme_classic() + 
  theme(legend.title = element_blank(), legend.text = element_text(size = axtext), legend.key.size = unit(3,"line")) + 
  theme(axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 2)))

plot.otherself.ai

if (saveplots == 1) {dev.off()}

```